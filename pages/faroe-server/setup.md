---
title: "Set up a Faroe server"
---

# Set up a Faroe server

A Faroe server is a server that exposes an [action invocation endpoint]() for Faroe server [actions]().

This may take up to an hour depending on how comfortable you are with the language and architecture. If you want to evaluate the server first, consider using the prebuilt local server by following the [Quick-start guide]().

_All implementations of interfaces must be thread-safe unless specified otherwise._

## Main storage

The first step is to define you main storage. The main storage is where session-like data will be stored (sessions, signups, signins, user password resets, user password updates, user email address updates, and user deletion).

The main storage is a key-value store that implements [`KeyValueStorageInterface`](). This storage should be strongly consistent. Any writes/updates should be immediately visible to all subsequent reads. Beyond this consistency guarantee, no other requirements are imposed. You may use a traditional persistent database with backups or, if you're fine with users possible getting signed out, use a temporary storage like an in-memory store.

Your implementation should store the record value, counter, and expiration timestamp under each key. The counter is used to prevent race conditions. If you plan to rely on your storage's built-in TTL mechanism, check that entries are deleted after expiration with minimal delay. Redis guarantees entires are deleted within 1 millisecond of expiration, while items in DynamoDB may not be deleted for hours after expiration.

An [SQLite implementation]() is available on GitHub.

```go
type KeyValueStorageInterface interface {
	Get(key string) ([]byte, int32, error)
	Set(key string, value []byte, expiresAt time.Time) error
	Add(key string, value []byte, expiresAt time.Time) error
	Update(key string, counter int32, value []byte, expiresAt time.Time) error
	Delete(key string) error
}
```

## Cache storage

The cache is an optional storage for storing sessions. Adding this will reduce the number of queries to your main storage.

It implements [`BasicKeyValueStorageInterface`](). Unlike `KeyValueStorageInterface`, it does not have to be strongly consistent.

```go
type BasicKeyValueStorageInterface interface {
	Get(key string) ([]byte, error)
	Set(key string, value []byte, expiresAt time.Time) error
	Delete(key string) error
}
```

## User password hash algorithm

The user password hash algorithm implements [`PasswordHashAlgorithmInterface`](). The ID is a unique identifier for the algorithm. We recommend including the parameters alongside the algorithm name like `argon2id.65536.3.1.32`.

We recommend using Argon2id with 64MiB of memory, 3 iterations, and 1 degree of parallelism. An [example implementation]() is available on GitHub.

```go
type PasswordHashAlgorithmInterface interface {
	Id() string
	SaltSize() int
	Hash(secret string, salt []byte) ([]byte, error)
}
```

## User password reset temporary password hashing

The user password reset temporary password hash algorithm also implements [`PasswordHashAlgorithmInterface`]().

Temporary passwords used in user password resets are generated by the server. Because they are much stronger than user-defined passwords, you may use a weaker hashing algorithm than for user passwords. That said, you should still treat them as passwords and use hashing algorithms intended for passwords. We recommend Argon2id with 16MiB of memory, 3 iterations, and 1 degree of parallelism.

## User server action invocation endpoint client

This client is used to send action invocation request to the user server's action invocation endpoint. It implements [`ActionInvocationEndpointClientInterface`]().

Because Faroe doesn't prescribe the authentication method used for action invocation endpoints, this is where you implement whatever authentication mechanism your user action endpoint uses.

```go
type ActionInvocationEndpointClientInterface interface {
	SendActionInvocationEndpointRequest(body string) (string, error)
}
```

## Frontend action rate limit storage

The rate limit storage stores data related to rate limits. This also implements [`KeyValueStorageInterface`]() like the main storage and must be strongly consistent.

Consider using a fast, in-memory storage here.

> Faroe does not implement IP-based rate limits.

## Action error logger

The `LogActionError()` method of [`ActionErrorLoggerInterface`]() will be used to log all internal errors.

```go
type ActionErrorLoggerInterface interface {
	LogActionError(timestamp time.Time, message string, actionInvocationId string, action string)
}
```

## Email sender

The email sender is an implementation of [`ActionEmailSenderInterface`]().

```go
type ActionEmailSenderInterface interface {
	SendSignupEmailAddressVerificationCode(emailAddress string, emailAddressVerificationCode string) error
	SendUserEmailAddressUpdateEmailVerificationCode(emailAddress string, displayName string, emailAddressVerificationCode string) error
	SendUserPasswordResetTemporaryPassword(emailAddress string, displayName string, temporaryPassword string) error

	SendUserSignedInNotification(emailAddress string, displayName string) error
	SendUserPasswordUpdatedNotification(emailAddress string, displayName string) error
	SendUserEmailAddressUpdatedNotification(emailAddress string, displayName string, newEmailAddress string) error
}
```

## Storage namespace

Storage entry keys are not globally namespaced. For example, an entry in the rate limit storage can have a same key as an entry in the cache. If you use a shared storage, make sure to prefix the key with `NAME.` (note the period) like `main.` and `rate_limit.`.

## Initialize actions

Initialize a new [`ActionsStruct`]().

If you do not have a cache, pass [`EmptyBasicKeyValueStorage`]() as the cache.

You can provide multiple user password hashing algorithms if your users use different algorithms. The first one will be used for hashing new passwords.

`maxConcurrentPasswordHashingProcesses` is the number of maximum CPU threads you want to dedicate to hashing passwords (user passwords and temporary passwords). Password hashing is expensive and will block the thread for the duration of the process.

```go
core := faroe.NewCore(
	mainStorage,
	cache,
	rateLimitStorage,
	errorLogger,
	[]faroe.PasswordHashAlgorithmInterface{userPasswordHashAlgorithm},
	temporaryPasswordHashAlgorithm,
	maxConcurrentPasswordHashingProcesses,
	faroe.RealClock,
	faroe.AllowAllEmailAddresses,
	emailSender,
	userActionInvocationEndpointClient,
	faroe.SessionConfigStruct{
		InactivityTimeout:     30 * 24 * time.Hour,
		ActivityCheckInterval: time.Minute,
		CacheExpiration:       time.Minute,
	},
)
```

## Create action invocation endpoint

Create a new [`ActionInvocationRequestResolverStruct`]().

```go
actionInvocationRequestResolver := faroe.NewActionInvocationRequestResolver(actions)
```

`ResolveRequestWithBlocklist()` takes an action invocation endpoint request body and returns the response body.

```go
import (
    "io"
	"net/http"

    "github.com/faroedev/faroe"
)

func handleRequest(w http.ResponseWriter, r *http.Request) {
    bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	resultJSON, err := actionInvocationRequestResolver.ResolveRequestWithBlocklist(string(bodyBytes), nil)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	w.Write([]byte(resultJSON))
	return
}
```
